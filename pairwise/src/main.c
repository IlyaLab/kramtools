
/**
  * This file serves 3 primary functions:
  * 1) finding and prepping the input matrix for processing.
  * 2) iterating through the input matrix' rows either by name or 
  *    using a possibly complex series of range specifications
  *    and for each pair calling a high-level analysis method
  * 3) routing the results to either
  *    a) immediate output using a specified formatter or
  *    b) a cache to be post-processed (for FDR control) and subsequently
  *       output.
  *
  * By far the bulk of the work of this file is memory mapping and parsing
  * the binary format of generated by the prep.py script.
  *
  * Audit:
  *   1) All error exits return -1. When used as webservice proper status
  *      returns is the least we can do...
  *   2) stdout is ONLY used for data output (at verbosity 0)
  *   3) Analysis failures (because of degeneracy) still return something
  *      the web service can deal with. Striving for data-as-error,
  *      instead of a separate error channel.
  */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <signal.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <getopt.h>
#include <stdbool.h>
#include <assert.h>

#include <gsl/gsl_errno.h>

#include "memmap.h"
#include "stattest.h"
#include "analysis.h"
#include "iter.h"
#include "fdr.h"
#include "global.h"
#include "format.h"

/**
 * Following constants are essentially defined by the Python script that
 * produces the binary matrices.
 */
const static char *SIGNATURE = "PAIRWISE";

#define SIZEOF_SIGNAT     ((size_t)8)
#define SIZEOF_ROW_HEADER ((size_t)4)
#define SIZEOF_DATUM      ((size_t)4)

#define MAXLEN_ROWNAME_PAIRS (512)

/***************************************************************************
 * externs
 */


/***************************************************************************
 * Globals & statics
 */

static double arg_q_value         = 0.0;
#define USING_FDR_CONTROL (arg_q_value > 0.0)

static bool  arg_webservice       = false;
static bool  arg_byname           = false;

static char  arg_outer_loop[ ITER_SPEC_BUFFER_LEN ];
static const char *DEFAULT_OUTER = ":";
static char  arg_inner_loop[ ITER_SPEC_BUFFER_LEN ];
static const char *DEFAULT_INNER = "+1";

static int   arg_dry_run          = 0;
static bool  arg_dump_header      = false;
static int   arg_verbosity        = 0;
static bool  arg_abort_on_bad_sig = false;

static unsigned _filtered[ CovarTypeCount ];

/**
  * Emit all results INCLUDING those with degeneracy.
  */
static bool  arg_exhaustive       = false;

#ifdef _DEBUG
/**
  * This debug-only option is for the purpose of full-pass testing
  * without loads of irrelevant output.
  */
static bool  arg_debug_silent     = false;
#endif


static int _nrow = 0;

/**
  * The binary matrix is accessed at runtime through this variable.
  * Notice, in particular, that the analysis code (analysis.cpp)
  * only has access to pairs of rows, NOT the whole matrix.
  * The matrix' structure and implementation is strictly encapsulated
  * within this file, and code in here dolls out just what analysis
  * requires: row pairs.
  */
static mapped_file_t matrix_file;

/***************************************************************************
 * Functions
 */

/**
  * Used only by the bsearch function to look up row names.
  */
static int _cmp_row_names( const void *pvl, const void *pvr ) {
	ROW_T *l = (ROW_T*)pvl;
	ROW_T *r = (ROW_T*)pvr;
	return strcmp( l->name, r->name );
}


/**
 * This, on the other hand is used to re-sort the row table for offset
 * lookup. The table arrives sorted by name (actually created in that order
 * by the preprocessor) to facilitate name lookup. If we're running in batch
 * mode we'll convert offsets to names.
 */
static int _cmp_row_offsets( const void *pvl, const void *pvr ) {
	ROW_T *l = (ROW_T*)pvl;
	ROW_T *r = (ROW_T*)pvr;
	return l->offset==r->offset ? 0 : ( l->offset < r->offset?-1:+1 );
}


static void _interrupt( int n ) {
	g_sigint_received = true;
}


static void _freeMatrix() {
	mmf_munmap( &matrix_file );
}


void panic( const char *src, int line ) {
	fprintf( stderr, "panic on %s:%d", src, line );
	abort();
}


/***************************************************************************
 * Output formats
 */

static void _emit_www(
		unsigned status, 
		const char *lname,
		const char *rname,
		FILE *fp ) {

	fprintf( fp, 
		"%s\t%s\t%s\t%d\t%.3e\t%.3f\n", 
		lname,
		rname,
		COVAR_TYPE_STR[g_summary.kind],
		g_summary.common.N,
		g_summary.common.P,
		g_summary.spearman_rho
	);
}

/**
 * This is used STRICTLY by the arg_byname case because we
 * KNOW that string names are available.
 */
static void (*_emit_byname)( 
		unsigned status, 
		const char * lf, const char * rf, FILE *fp ) = _emit_www;

/**
 * Encapsulates all the decision making regarding actual emission of
 * results.
 */
static void _filter( unsigned a, unsigned b, unsigned status ) {
#ifdef _DEBUG
	if( ! arg_debug_silent ) {
#endif
		if( (( g_summary.common.P <= arg_p_value ) && ( status == 0 ) ) 
			|| arg_exhaustive ) {
			g_format( a, b, status );
		} else {
			assert( g_summary.kind < CovarTypeCount );
			_filtered[ g_summary.kind ] += 1;
		}
#ifdef _DEBUG
	}	
#endif
}


static void (*_process_pair_result)( unsigned a, unsigned b, unsigned status ) = _filter;

static void _error_handler(const char * reason,
                        const char * file,
                        int line,
                        int gsl_errno) {
	fprintf( stderr,
		"#GSL error(%d): %s\n"
		"#GSL error  at: %s:%d\n", 
		gsl_errno, reason, file, line );
}

/***************************************************************************
 */

static const char *USAGE_FULL = 
"%s [ options ] <prepped_binary_matrix> [ <output_file> ]\n"
"version: %d.%d.%d\n"
"Input options:\n"
"  --byname|-N             Run pairwise analysis on row pairs specified\n"
"                          by name (on stdin, unless -i given).\n"
"  --input|-i <filename>   Take named pairs from the specified input file.\n"
"                          (This is only meaningful with the -N option.)\n"
"Processing options:\n"
"  --min-ct-cell <min>     Cull from the contingency table of categorical\n"
"                          feature pairs rows/columns containing cells\n"
"                          with fewer than <min> samples. [%d] \n"
"Output options:\n"
"  --min-mx-cell <min>     Treat mixed feature pairs where:\n"
"                          1) the categorical feature is binary and\n"
"                          2) one of the classes occurs in fewer than\n"
"                             <min> samples\n"
"                          ...as degenerate. [%d]\n"
"  --min-samples|-M <min>  Treat feature pairs in which there are fewer\n"
"                          than <min> covariates (after filtering NAs)\n"
"                          ...as degenerate. [%d]\n"
"  --pvalue|-p <max>       Only emit associations with p-values <= max. [%.2f]\n"
"  --exhaustive | -X       Emit ALL results without any filtering whatsoever.\n"
"                          This is mainly for testing.\n"
"\n"
"                           --- row pair iteration options ---\n"
"\n"
"  --outer  |-O <iteration spec>  See Interation Control below. [\"%s\"]\n"
"  --inner  |-I <iteration spec>  See Interation Control below. [\"%s\"]\n"
"\n"
"  --dry-run   | -D <count> Don't actually analyze; just emit the list of\n"
"                          row offsets that the given iteration specs will\n"
"                          produce for a matrix with <count> rows. [%d]\n"
#ifdef _DEBUG
"  --quiet     | -Q        Don't emit any output (debuggin).\n"
#endif
"  --format    | -F        one of \"std\" or \"short\". Default is \"TCGA\".\n"
"  --verbosity | -v <int>  Controls emission of secondary results\n"
"                          and warnings.  0 => \"nothing extra\". [%d]\n"
"\n"
"Notes:\n"
". Values in brackes '[ ]' above are defaults.\n"
". The --inner/--outer iteration spec options are MUTUALLY EXCLUSIVE with\n"
"  the --byname option.\n"
". Categorical features MUST have <= %d categories.\n"
". Integer row specifiers are always offsets (0-based), so the 1st row is\n"
"  row 0.\n"
"Row selection:\n"
". Row selection is accomplished by specifying the iteration ranges\n"
"  for a pair of nested loops.\n"
". Iteration ranges are Python range format: start:stop:step.\n"
". The intervals are half-open (like Python), so the 1st iterate is \n"
"  <start> and the last iterate is <stop>-1.\n"
". Any of the three values may be skipped.\n"
"    If <start> is skipped (e.g. \":3:3\") it defaults to 0.\n"
"    If <stop> is skipped (e.g. \"3::3\") it defaults to the matrix' row\n"
"    count.\n"
"    If <step> is skipped (e.g. \"3:3\") it defaults to 1\n"
". Additionally, a '+' in front of the --inner (e.g. +1:) means treat\n"
"  the inner start:stop bounds as offsets relative to the outer loop index.\n"
". '+' is illegal on the outer loop spec; its range is always absolute.\n"
". The iteration control will NEVER allow a pair to be created\n"
"  from the same row (an offset used twice), so don't worry about that.\n"
". Finally, you may supply comma-delimited sequences of iteration specs\n"
"  for both --inner and --outer, e.g. \"--outer 0:2,9::2\". All the\n"
"  above rules still apply unchanged.\n"
". Experiment with them using the -D option.\n"
". Expressions for row selection must be < %d characters.\n"
#ifdef _DEBUG
"This is a _DEBUG build; assertions are enabled.\n"
#endif
"Bug rkramer@systemsbiology.org with troubles.\n";

static const char *USAGE_WWW = 
"Usage:\n"
"%s <path-to-binary-matrix>\n"
"    stdin: 2 tab-delimited column table of row names\n"
"   stdout: tab-delimited column output\n"
"...and make sure categorical features have <= %d categories!\n"
#ifdef _DEBUG
"This is a _DEBUG build.\n"
#endif
"Bug rkramer@systemsbiology.org with troubles.\n";

static void _print_usage( const char *exename, FILE *fp ) {

	if( arg_webservice )
		fprintf( fp, USAGE_WWW, 
			exename,
			_MAX_CATEGORIES );
	else
		fprintf( fp, USAGE_FULL,
			exename,
			_VER_MAJ, _VER_MIN, _VER_FIX,
			arg_min_cell_count,
			arg_min_sample_count,
			arg_min_mixb_count,
			arg_p_value,
			arg_outer_loop,
			arg_inner_loop,
			arg_dry_run,
			arg_verbosity,
			_MAX_CATEGORIES, ITER_SPEC_BUFFER_LEN );
}


int main( int argc, char *argv[] ) {

	static char filename_in[  FILENAME_MAX+1 ];
	static char filename_out[ FILENAME_MAX+1 ];

	int exit_status = EXIT_SUCCESS;

	struct stat info;
	unsigned offmap = 0, offstr = 0;
	unsigned int SIZEOF_HEADER = 0;

	int ndcol = 0; // number DATA columns

	FILE *fp = NULL;

	/**
	  * Sanity checks for critical assumptions made throughout the code.
	  */

	if( sizeof(float) != sizeof(unsigned) ) {
		fprintf( stderr, "sizeof(float)(%ld) != sizeof(unsigned)(%ld)."
			"That's a problem!\n", 
			sizeof(float), 
			sizeof(unsigned) );
		abort();
	}

	/**
	  * Mandatory initializations.
	  */

	memset( _filtered, 0, sizeof(_filtered) );
	strcpy( arg_outer_loop, DEFAULT_OUTER );
	strcpy( arg_inner_loop, DEFAULT_INNER );

	assert( sizeof(unsigned int) == sizeof(float) );
	assert( SIZEOF_ROW_HEADER    == SIZEOF_DATUM );

	memset( filename_in,  0, sizeof(filename_in) );
	memset( filename_out, 0, sizeof(filename_out));
	memset( &matrix_file,    0, sizeof(matrix_file)    );

	/**
	 * This auto(de)selects options related to running this executable
	 * under the TCGA web service.
	 */

	{
		const char *ps
			= strstr( argv[0], "-www" );
		arg_webservice 
			= ( NULL != ps ) && strlen(ps) == 4; // confirm it's at the end.
	}

	gsl_set_error_handler( _error_handler );

	/**
	 * Argument checks
	 */

	if( argc < 2 ) { // absolute minimum args: <executable name> <input matrix>
		_print_usage( argv[0], stdout );
		exit(0);
	}

	/**
	 * Running as a web service implies some changes to default arguments
	 * ...and NOTHING else. For the purpose of minimizing testing paths,
	 * The webservice executable is identical in every respect to the 
	 * command line too and SHOULD BE MAINTAINED SO.
	 */

	if( arg_webservice ) {
		arg_byname = true;
		arg_verbosity = 0;
		arg_p_value    = 1.0; // implies NO filtering.
	}

	do {

		static const char *CHAR_OPTIONS 
			= "Ni:M:p:XO:I:D:HQF:v:h?";
		static struct option LONG_OPTIONS[] = {
			{"byname",     no_argument,      0,'N'},
			{"input",      required_argument,0,'i'},
			{"min-ct-cell",required_argument,0, 256 }, // no short equivalents
			{"min-mx-cell",required_argument,0, 257 }, // no short equivalents
			{"min-samples",required_argument,0,'M'},
			{"pvalue",     required_argument,0,'p'},
			{"exhaustive", no_argument,      0,'X'},
			{"outer",      required_argument,0,'O'},
			{"inner",      required_argument,0,'I'},
			{"dry-run",    required_argument,0,'D'},
			{"header",     no_argument,      0,'H'},
			{"fdr",        required_argument,0,'q'},
#ifdef _DEBUG
			{"quiet",      no_argument,      0,'Q'},
#endif
			{"format",     required_argument,0,'F'},
			{"verbosity",  required_argument,0,'v'},
			{ NULL,        0,0, 0 }
		};

		int arg_index = 0;
		const int c 
			= getopt_long( argc, argv, CHAR_OPTIONS, LONG_OPTIONS, &arg_index );
		switch (c) {

		case 'N':
			arg_byname = true;
			break;

		case 'i':
			strcpy( filename_in, optarg );
			break;

		case 256: // ...because I haven't defined a short form for this
			arg_min_cell_count = atoi( optarg );
			break;

		case 257: // ...because I haven't defined a short form for this
			arg_min_mixb_count = atoi( optarg );
			break;

		case 'M':
			arg_min_sample_count = atoi( optarg );
			if( arg_min_sample_count < 2 ) {
				fprintf( stderr, 
					"Seriously...%d samples is acceptable?\n"
					"I don't think so...\n", 
					arg_min_sample_count );
				exit(-1);
			}
			break;

		case 'p':
			arg_p_value = atof( optarg );
			if( ! ( 0 < arg_p_value ) ) {
				fprintf( stderr,
					"error: specified p-value %.3f will preclude all output.\n",
					arg_p_value );
				abort();
			} else
			if( ! ( arg_p_value < 1.0 ) ) {
				fprintf( stderr,
					"warning: p-value %.3f will filter nothing.\n"
					"\tIs this really what you want?\n", 
					arg_p_value );
			}
			break;

		case 'I':
			if( ! ( strlen(optarg) < sizeof(arg_inner_loop) ) ) {
				fprintf( stderr, "error: arg too long!\n" );
				exit(-1);
			}
			strcpy( arg_inner_loop, optarg );
			break;

		case 'O':
			if( ! ( strlen(optarg) < sizeof(arg_outer_loop) ) ) {
				fprintf( stderr, "error: arg too long!\n" );
				exit(-1);
			}
			strcpy( arg_outer_loop, optarg );
			break;

		case 'X':
			arg_exhaustive = true;
			break;

		case 'q':
			arg_q_value = atof( optarg );
			_process_pair_result = fdr_aggregate;
			break;

		case 'Q':
#ifdef _DEBUG
			arg_debug_silent = true;
#endif
			break;
		case 'F':
			if( strncmp("std",optarg, 3 ) == 0 )
				g_format = format_standard;
			else
			if( strncmp("short",optarg, 5 ) == 0 )
				g_format = format_abbreviated;
			break;

		case 'D':
			arg_dry_run = atoi( optarg );
			break;

		case 'H':
			arg_dump_header = true;
			break;

		case 'v':
			arg_verbosity = atoi( optarg );
			break;

		case -1: // ...signals no more options.
			break;
		default:
			printf ("error: unknown option: %c\n", c );
			exit(-1);
		}
		if( -1 == c ) break;

	} while( true );

	/**
	  * Parsed iteration specs (default or otherwise) are
	  * necessary to initialize the iterator parameters.
	  */
	if( iter_parse( arg_outer_loop, arg_inner_loop ) ) 
		exit(-1);

	/**
	  * The iteration specifier format allows for potentially quite complex
	  * iteration schemes. The following provides a means for users to "try 
	  * out" various iteration specifications without doing any real work.
	  */
	if( arg_dry_run > 0 ) {
		int a, b;
		if( iter_begin( arg_dry_run, &a, &b ) ) {
			do {
				fprintf( stdout, "%d\t%d\n", a, b );
			} while( iter_next( &a, &b ) );
		}
		exit(0);
	}

	/**
	  * 0) Validate and reconcile parameters.
	  */

	if( arg_q_value > 0.0 && arg_byname ) {
		fprintf( stderr, "FDR cannot be used in the context of \"by name\" output.\n" );
		abort();
	}

	/**
	  * 1) Acquire the input matrix name and (optional) output filename.
	  */

	if( optind < argc ) {

		/**
		  * The first (and possibly last) of the non-flag arguments
		  * is the input matrix.
		  */
		strcpy( matrix_file.name, argv[optind++] );

		if( optind < argc ) {

			/**
			 * If another non-flag is present it's the optional
			 * output filename.
			 */
			strcpy( filename_out, argv[optind++] );
		}

	} else {

		fprintf( stderr,
			"too few options ( argc(%d) <= optind(%d) )\n", argc, optind );
		_print_usage( argv[0], stderr );
		exit(-1);
	}

	/**
	  * Fail early! If the specified input doesn't exist or is not readable
	  * don't even proceed to memory mapping...too much to clean up.
	  */
	
	if( stat( matrix_file.name, &info ) 
			|| info.st_size == 0 
			|| ( ! S_ISREG(info.st_mode) ) ) {
		fprintf( stderr, 
			"error: '%s' is missing, empty, unreadable or not a regular file\n", 
			matrix_file.name );
		abort();
	}

	/**
	 * 2) Read the matrix dimensions out of the binary file's header.
	 *    Yes, this could be done after mapping--maybe ought to be,
	 *    but one value in the header (offmap) determines the size of the
	 *    mapping.
	 */

	fp = fopen( matrix_file.name, "r" );
	if( fp ) {

		const size_t SIGLEN
			= strlen(SIGNATURE);
		char *sig = (char*)alloca( SIGLEN+1);
		sig[SIGLEN] = 0;

		fread( sig, sizeof(char), SIGLEN,    fp );
		fread( &SIZEOF_HEADER, sizeof(unsigned), 1, fp );
		fread( &_nrow,  sizeof(unsigned), 1, fp );
		fread( &ndcol,  sizeof(unsigned), 1, fp );
		fread( &offstr, sizeof(unsigned), 1, fp );
		fread( &offmap, sizeof(unsigned), 1, fp );
		fclose(fp);

		if( strncmp( sig, SIGNATURE, SIGLEN ) ) {
			fprintf( stderr, 
				"error: file signature '%s' is not the expected '%s'\n"
				"\tAre you looking at the right file!?\n",
				sig, SIGNATURE );
			if( arg_abort_on_bad_sig )
				abort();
		}

		if( arg_dump_header ) {
			fprintf( stdout,
				"%s header contains...\n"
				"   signature: %s\n"
				" header size: %d bytes\n"
				" matrix size: %d rows\n"
				" matrix size: %d columns\n"
				"string table: %d (byte offset from file start)\n"
				"   map table: %d (byte offset from file start)\n",
				matrix_file.name,
				sig,
				SIZEOF_HEADER,
				_nrow,
				ndcol,
				offstr,
				offmap );
			exit(0);
		}
	}

	/**
	 * 3) If the file includes a row map go ahead and allocate
	 *    space now. We'll relocate right after memory mapping
	 *    (which brings the strings array into memory "for free".
	 */
	if( offmap > 0 ) {
		g_rowmap = (row_t*)calloc( _nrow, sizeof(row_t) );
		if( NULL == g_rowmap ) {
			fprintf( stderr, 
				"error: failed allocating space for row map\n" );
			abort();
		}
	}

	// Note that there is no point in memory mapping the entire
	// file...only that part through the strings array. Even though
	// memory mapping allows the data to be shared by multiple processes
	// on a multi-CPU host, the mapping need not start at the same address
	// in each process, so the string pointers in the row map in general
	// must be computed WITHIN each process based on the local mapping.

	/**
	  * 4) Now load the matrix.
	  *    Notice if a string table is present we only load up to and 
	  *    including the strings, not the map at the end. Otherwise,
	  *    the entire file is loaded.
	  */

	if( mmf_memmap( 
			&matrix_file, 
			offmap > 0 ? offmap : info.st_size ) == 0 ) {

		/**
		 * Sanity checking parameters is only feasible if a string
		 * table and row map were NOT included because they involve
		 * padding which renders the arithmetic indeterminate.
		 */
		if( offmap == 0 ) {

			const size_t expected
				= SIZEOF_HEADER
				+ _nrow*( ndcol * SIZEOF_DATUM + SIZEOF_ROW_HEADER );

			if( expected != matrix_file.len ) {

				mmf_munmap( &matrix_file );

				fprintf( stderr,
					"error: mapped %ld bytes (file size), but can't reconcile this with:\n"
					"%d matrix header\n"
					"%d rows\n"
					"%d data columns with %ld-byte data\n"
					"%ld-byte row headers\n"
					"...totalling %ld expected bytes. Aborting...\n",
					matrix_file.len,
					SIZEOF_HEADER,
					_nrow, ndcol, SIZEOF_DATUM,
					SIZEOF_ROW_HEADER, 
					expected );
				exit(-1);
			}
		}

		g_matrix_body 
			= (unsigned int*)( ((char*)matrix_file.mem) 
			+ SIZEOF_HEADER );

		atexit( _freeMatrix );
	} else {
		fprintf( stderr, "error: memory mapping failed\n" );
		if( g_rowmap ) free( g_rowmap ); // only resource allocated above.
		abort();
	}


	/**
	 * 5) IF a string table and associated row map are present, the strings
	 *    have already been loaded (within the memory mapping above). All
	 *    that remains is to compute pointers ("relocations") which are 
	 *    necessarily specific to each process' address space...
	 */
	if( offmap > 0 ) {
		const char *STRINGS
			= ((char*)matrix_file.mem) + offstr;
		FILE *fp = fopen( matrix_file.name, "r" );
		if( fp ) {
			int i;
			if( fseek( fp, offmap, SEEK_SET ) ) 
				panic(__FILE__, __LINE__ );
			for(i = 0; i < _nrow; i++ ) {
				unsigned off_idx[2];
				if( fread( &off_idx, sizeof(unsigned), 2, fp ) != 2 )
					panic(__FILE__, __LINE__ );
				g_rowmap[i].name   = STRINGS + off_idx[0];
				g_rowmap[i].offset =           off_idx[1];
			}
			fclose( fp );
		}

		// Moreover, if we're NOT doing a "byname" run, then we're in
		// one of the batch modes, so re-sort the rowmap so that we
		// can lookup names by row offset...
	
		if( ! arg_byname )
			qsort( g_rowmap, _nrow, sizeof(ROW_T), _cmp_row_offsets );
	}

	if( ! arg_webservice ) {
		if( SIG_ERR == signal( SIGINT, _interrupt ) ) {
			fprintf( stderr,
				"warning: failed installing interrupt handler\n"
				"\tCtrl-C will terminated gracelessly\n" );
		}
	}

	g_fp_output 
		= strlen(filename_out) > 0 
		? fopen( filename_out, "w" ) 
		: stdout;

	if( analysis_init( ndcol ) ) {
		fprintf( stderr, "error: analysis_init(%d)\n", ndcol );
		exit(-1);
	}

	if( arg_verbosity > 0 ) 
		fprintf( g_fp_output, "# %d rows X %d (data) columns\n", _nrow, ndcol );

	// This...
	g_COLUMNS = ndcol+1;
	// ...and the fact that g_matrix_body is a ptr to unsigned int are why
	// I require SIZEOF_ROW_HEADER == SIZEOF_DATUM.

	if( arg_byname ) {

		ROW_T *lfeat, *rfeat;
		row_t l_key, r_key;
		size_t n = 0;
		char *pc, *line = NULL;
		FILE *fpi
			= strlen(filename_in) > 0
			? fopen( filename_in, "r" )
			: stdin;

		while( getline( &line, &n, fpi ) > 0 ) {

			// Parse the two names out of the line.

			pc = strchr( line, '\t' ); // ...or any whitespace?
			if( NULL == pc ) {
				fprintf( stderr, "error: no tab found in '%s'. Skipping it.\n", line );
				exit_status = -1;
				continue;
			}

			l_key.name = line;
			*pc++ = '\0'; // Separate left from right string.
			r_key.name = pc;
			// Find and strip newline, if present...
			pc = strchr( pc, '\n' );
			if( pc ) *pc = '\0';

			// ...then lookup the names.

			lfeat = (ROW_T*)bsearch( &l_key, g_rowmap, _nrow, sizeof(row_t), _cmp_row_names );
			rfeat = (ROW_T*)bsearch( &r_key, g_rowmap, _nrow, sizeof(row_t), _cmp_row_names );

			if( NULL != lfeat && NULL != rfeat ) {

				const unsigned int *l_ptr
					= g_matrix_body + g_COLUMNS*lfeat->offset;
				const unsigned int *r_ptr
					= g_matrix_body + g_COLUMNS*rfeat->offset;
				
				clear_summary( &g_summary );

				const unsigned status = analysis_exec( 
						*l_ptr, (const float*)(l_ptr+1),
						*r_ptr, (const float*)(r_ptr+1),
						&g_summary );

				// No filtering here because (presumably) user is specifying
				// pairs--presumably they want to see whatever results are.
				// (This is primarily motivated by the web service.)
	
				_emit_byname( status, lfeat->name, rfeat->name, g_fp_output );

			} else {
				fprintf( stderr,
					"error: one or both of...\n\t1) %s\n\t2) %s\n...not found.\n",
					l_key.name,
					r_key.name );
				exit_status = -2;
			}
		}

		free( line );
		fclose( fpi );

	} else {

		int a, b;
		if( USING_FDR_CONTROL ) {
			g_fp_cache = tmpfile();
			if( NULL == g_fp_cache ) {
				perror( "creating a temporary file" );
				abort();
			}
		}

		if( iter_begin( _nrow, &a, &b ) ) {
#ifdef _DEBUG
			iter_dump( "# iter ", stderr );
#endif
			do {

				const unsigned *pa = g_matrix_body + g_COLUMNS*a;
				const unsigned *pb = g_matrix_body + g_COLUMNS*b;

				clear_summary( &g_summary );

				const unsigned status = analysis_exec( 
						*pa, (const float*)(pa+1),
						*pb, (const float*)(pb+1),
						&g_summary );

				_process_pair_result( a, b, status );

				if( g_sigint_received ) {
					time_t now = time(NULL);
					fprintf( stderr, "# main analysis loop interrupted @ %s", ctime(&now) );
					break;
				}

			} while( iter_next( &a, &b ) );

			// Post process results if FDR is in effect and the 
			// 1st pass was allowed to complete.
			// (Post-processing involves a repetition of all of the
			//  above loop FOR A SUBSET of the original input.)

			if( USING_FDR_CONTROL ) {
				if( ! g_sigint_received ) {
					fdr_postprocess( g_fp_cache, arg_q_value );
				}
				if( g_fp_cache ) 
					fclose( g_fp_cache );
			}
		}
	}

	if( arg_verbosity > 0 ) {
		int i;
		fprintf( g_fp_output, "# Filter counts follow:\n" );
		for(i = 0; i < (int)CovarTypeCount; i++ ) {
			fprintf( g_fp_output, "# %s %d\n", COVAR_TYPE_STR[i], _filtered[i] );
		}
	}

	fclose( g_fp_output );

	if( g_rowmap )
		free( g_rowmap );

	return exit_status;
}

