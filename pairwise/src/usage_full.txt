USAGE_UNABRIDGED
%s version: %d.%d.%d%s %s
Usage...
%s [ options ] [ <input matrix> ] [ <output_file> ]

============================================================================
Input/output
============================================================================

Both input and output filenames are optional. 
If either (or both) are missing stdin or stdout is used for the missing
file, as appropriate. If only one filename is present it is treated as 
input if it exists and output otherwise, and a std* stream is used for
the other.


============================================================================
General options:
============================================================================

#ifdef HAVE_LUA
  --script | -s { <literal Lua script> | <filename> }

	Read the specified Lua script. The argument may contain either inline 
	Lua script or it may name a file containing Lua script. The script can
	contain:
	1. a function to interpret the feature classes of the rows in the 
	   input matrix, and/or...
	2. a coroutine to generate pairs of indices specifying the features/rows
	   to analyze.
	See below.

#endif
  --dry-run | -D

#ifdef HAVE_LUA
	If Lua script has been provided for feature index generation, this
	triggers emission to stdout of the sequence of offsets generated by
	the script. This is for debugging Lua scripts.
	Define the environment variable DRY_RUN_COUNT to inform the coroutine
	how many rows are in the (hypothetical) matrix. e.g. The command line

		DRY_RUN_COUNT=100 ./pairwise ... 

	...passes 100 to your pairs generator script.

#endif
	If no script was provided this causes %s to exit -just before-
	analysis begins. This provides a way to verify that a candidate input
	matrix is well-formatted and (depending on verbosity) obtain other
	information about what -would- be done.

============================================================================
Input matrix options:
============================================================================

  --no-header | -h

	Treat all lines of the input matrix as data. Otherwise (by default) the 
	first non-comment, non-blank line is assumed to be a header and ignored.

  --no-row-labels | -r

	The input matrix does not have row labels; treat the first field on each
	line as data. Otherwise (by default) the first column is assumed to
	contain row labels (metadata not data).

  --type-parser | -t  {<Lua function name>|string}

	Call the specified function (in the Lua script) to infer feature class.
	By default, if row labels are present the FIRST CHARACTER of each row
	label is treated as the feature's statistical class identifier:
		  B: boolean
		C|F: categorical (factor)
		D|O: ordinal (integral data)
		  N: numeric (continuous, floating point data)
	The second character MUST be punctuation.

	If the argument of --type-parser is the special string "%s" features'
	statistical classes are inferred from the input matrix' data using 
	the following rules:
	  1. If data is symbolic (strings) or integral and the cardinality 
	     of the set of all values (in a feature) is 2, the feature is 
	     treated as boolean data.
	  2. Symbolic or integral data with cardinality <= 32 is treated
	     as categorical.
	  3. Integral data with cardinality > 32 is treated as ordinal(*).
	  4. Presence of any floating-point syntax (a decimal point or
	     exponential notation) implies continuous data.
	  (*) Currently, no statistical methods specific to ordinal data
	      are implemented.

  --na-regex | -N  [ "%s" ]

	A regular expression describing what string is used in the input to 
	indicate missing data, i.e. "NA". See information on parsing library.

============================================================================
Feature (row) pair selection options:
============================================================================

These options are mutually exclusive; they are listed below in order of 
precedence. If a command line contains more than one of the following
options, --pair overrides --by-{name|index}.
#ifdef HAVE_LUA
--by-{name|index} overrides --coroutine.
#endif

  --pair | -P      <row1>,<row2>

    Analyze the single comma-separated pair of features.
	"rowX" can be either a feature name or an index.
	An identifier consisting entirely of digits is treated as an index.

  --by-name | -n   { <filename> | "-" | "stdin" }

	Read pair names from the specified file ('-' means stdin).
	Each LINE of input must contain exactly two tab-separated strings.

  --by-index | -x  { <filename> | "-" | "stdin" }

    Read pair of indices from the specified file ('-' means stdin).
	The input stream or file can be very free-form:
	-- Every contiguous sequence of decimal digits in the stream is
	   treated as a row index.
	-- Every consecutive pair of indices is treated as a feature pair
	   specifier.
	-- Any non-digit character(s) can be used as separators, and
	   no distinction is made between the separators within pairs
	   and separators between pairs.
	In other words exact format doesn't matter--digits need only by
	separated by non-digits.

#ifdef HAVE_LUA
  --coroutine | -c  [ "%s" ]

	Indicates the name of a coroutine in the Lua script to call
	for index pairs. Of course, the default is sought only if a script 
	was specified.

#endif
If none of the preceding options are given, then analysis is run for
all N-choose-2 pairs of features using the "natural" ordering.

============================================================================
Categorical (contingency table) options:
============================================================================

  --min-ct-cell <min>  [%d] 

	Cull from the contingency table of categorical feature pairs 
	rows/columns containing cells with fewer than <min> samples.

  --min-mx-cell <min>  [%d] 

	Treat mixed feature pairs where:
	  1) the categorical feature is binary and
	  2) one of the classes occurs in fewer than
		 <min> samples
	  ...as degenerate (errors).

  --min-samples | -M <min> [%d]
	Treat feature pairs in which there are fewer than <min> covariates
	(after filtering NAs) as degenerate (errors).

============================================================================
Output filters:
============================================================================

  --p-value | -p <max>  [%.2f]
  
	Only emit associations with p-values <= max.

  --status-mask | -S <mask> [ 0x%02x ]

	Normally tests that failed to even produce a p-value are filtered 
	from the output. This (advanced!) argument gives you control over
	how failed tests are filtered.
	Several kinds of degeneracy can cause statistical tests to be either
	infeasible to run or to yield infinite or NaN results.

	0x01:Too few (non-missing) pairs (for the statistical test)
	0x02:Degeneracy (e.g. constant value) in one feature of pair
	0x04:Degeneracy in covariate pairs (e.g. all non-missing pairs same)
	0x08:Floating-point trouble (NaN or +/- infinity produced)
	0x10:Too many categories

	Setting the corresponding bit in the mask -allows- filtering on that
	condition. So setting the mask to 0 precludes all filtering on errors.
	(Though p-value filtering remains independent.)

  --format | -f  [ "%s" ]

	Either one of the magic values ("%s" or "%s") or a format specifier.
	See the README for a full description.

  --fdr | -q

	False-discovery rate control.

  --strict | -S  [%s]

	Treat warning conditions as errors and abort.
	Warnings don't necessarily preclude continuing.

  --verbosity | -v <int>  [%d]

	Controls emission of secondary results and warnings.  
	0 => "nothing extra".

#ifdef _DEBUG
  --debug

	This option accepts strings to control debug functionality.
	If you're an end-user, you probably shouldn't even be seeing this;
	you're running a debug version.  See the source code.
#endif

============================================================================
Notes:
============================================================================

. Values in brackets '[ ]' above are defaults.
. Options for which no default is listed either have no default or the
  default is the natural opposite of the option.
. "Index" everywhere actually means offset; the first row is row 0.
. Parsing and preprocessing of the input matrix is handled by an independent
  library. See its documentation for further information.
. If the name of the executable file of (or symlink to) this program ends 
  in the suffix "%s", very different defaults are activiated. 
  See the source code or...

============================================================================
Manifest limitations
============================================================================

. Categorical features MUST have <= %d categories.
. No feature may have more than %d missing values.

Bug %s with troubles.

