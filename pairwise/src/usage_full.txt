USAGE_UNABRIDGED
%s version: %d.%d.%d %s
Usage...
%s [ options ] [ <input matrix> ] [ <output_file> ]

============================================================================
Input/output
============================================================================

Both input and output filenames are optional. 
If either (or both) are missing stdin or stdout is used for the missing
file, as appropriate. If only one filename is present it is treated as 
input if it exists and output otherwise, and a std* stream is used for
the other.


============================================================================
General options:
============================================================================

#ifdef HAVE_LUA
  --script | -s { <literal Lua script> | <filename> }

	Read the specified Lua script. The argument may contain either inline 
	Lua script or it may name a file containing Lua script. The script can
	contain:
	1. a function to interpret the feature classes of the rows in the 
	   input matrix, and/or...
	2. a coroutine to generate pairs of indices specifying the features/rows
	   to analyze.
	See below.

#endif
  --dry-run | -D

#ifdef HAVE_LUA
	If Lua script has been provided for feature index generation, this
	triggers emission to stdout of the sequence of offsets generated by
	the script. This is for debugging Lua scripts.
#endif
	If no script was provided this causes %s to exit -just before-
	analysis begins. This provides a way to verify that a candidate input
	matrix is well-formatted and (depending on verbosity) obtain other
	information about what -would- be done.

============================================================================
Input matrix options:
============================================================================

  --no-header | -h

	Treat all lines of the input matrix as data. Otherwise (by default) the 
	first non-comment, non-blank line is assumed to be a header and ignored.

  --no-row-labels | -r

	The input matrix does not have row labels; treat the first field on each
	line as data. Otherwise (by default) the first column is assumed to
	contain row labels (metadata not data).

  --type-parser | -t  {<Lua function name>|string}

	Call the specified function (in the Lua script) to infer feature class.
	By default, if row labels are present the FIRST CHARACTER of each row
	label is treated as the feature's statistical class identifier:
		  B: boolean
		C|F: categorical (factor)
		  O: ordinal (integral data)
		  N: numeric (continuous, floating point data)

	If the argument of --type-parser is the special string "%s" feature's
	statistical classes are inferred from the input matrix' data using 
	the following rules:
		symbolic (strings) or integral data => boolean
		symbolic (strings) or integral data => categorical
		                      integral data => ordinal
		                     floating-point => continuuos
		(The presence of '.' or exponential notation is sufficient to
		 imply a floating-point field.)

  --na-regex | -N  [ "%s" ]

	A regular expression describing what string is used in the input to 
	indicate missing data, i.e. "NA". See information on parsing library.

============================================================================
Feature (row) pair selection options:
============================================================================

These options are listed in order of precedence; if multiple appear on the
command line, earlier options override later ones.

  --pair | -P      <row1>,<row2>

    Analyze the single comma-separated pair of features.
	"rowX" can be either a feature name or an index.
	An identifier consisting entirely of digits is treated as an index.

  --by-name | -n   { <filename> | "-" | "stdin" }

	Read pair names from the specified file ('-' means stdin).
	Each LINE of input must contain exactly two tab-separated strings.

  --by-index | -x  { <filename> | "-" | "stdin" }

    Read pair of indices from the specified file ('-' means stdin).
	-- Every contiguous sequence of decimal digits in the stream is
	   treated as a row index.
	-- Every consecutive pair of indices is treated as a feature pair
	   specifier.
	-- Any non-digit character(s) can be used as separators, and
	   no distinction is made between the separators within pairs
	   and separators between pairs.

#ifdef HAVE_LUA
  --coroutine | -c  [ "%s" ]

	Indicates the name of a coroutine in the Lua script to call
	for index pairs. The default is sough
#endif

If none of the preceding options are given then analysis is run for
all N-choose-2 pairs of features using the "natural" ordering.

============================================================================
Categorical (contingency table) options:
============================================================================

  --min-ct-cell <min>  [%d] 

	Cull from the contingency table of categorical feature pairs 
	rows/columns containing cells with fewer than <min> samples.

  --min-mx-cell <min>  [%d] 

	Treat mixed feature pairs where:
	  1) the categorical feature is binary and
	  2) one of the classes occurs in fewer than
		 <min> samples
	  ...as degenerate (errors).

  --min-samples | -M <min> [%d]
	Treat feature pairs in which there are fewer than <min> covariates
	(after filtering NAs) as degenerate (errors).

============================================================================
Output filters:
============================================================================

  --p-value | -p <max>  [%.2f]
  
	Only emit associations with p-values <= max.

  --format | -f  [ "%s" ]

	One of "std" or "short". Default is "TCGA".

  --fdr | -q

	False-discovery rate control.

  --strict | -S  [%s]

	Treat warning conditions as errors and abort.
	Warnings don't necessarily preclude continuing.

  --verbosity | -v <int>  [%d]

	Controls emission of secondary results and warnings.  
	0 => "nothing extra".

#ifdef _DEBUG
  --debug

	This option accepts strings to control debug functionality.
	If you're an end-user, you probably shouldn't even be seeing this;
	you're running a debug version.  See the source code.
#endif

Notes:
. Values in brackets '[ ]' above are defaults.
. Options for which no default is listed either have no default or the
  default is the natural opposite of the option.
. "Index" everywhere actually means offset; the first row is row 0.
. Categorical features MUST have <= %d categories.
. Parsing and preprocessing of the input matrix is handled by an independent
  library. See its documentation for further information.
. If the name of the executable file of (or symlink to) this program ends 
  in the suffix "%s", very different defaults are activiated. 
  See the source code or...
Bug %s with troubles.

